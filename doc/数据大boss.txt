数据大BOSS，主要功能，管理所有不属于任何模块的系统公共配置信息，所有的跨模块数据，以及各模块跨处理周期的数据（比如上一个处理的数据的ID，上一次数据处理是否顺利完成，有这个可以做故障检测，跳帧处理等；当然跟踪算法所需要的历史疑似目标也在这里），管理共享内存的申请与释放，包括模块之间的共享内存和当个模块私有的跨周期数据。这个数据大BOSS还会创建一个和应用程序共有的数据库。

数据大BOSS，应该利用这个数据库，对我们数据处理模块之间的结果进行保存，比如我们检测的疑似信号的框框，目标跟踪数据，目标融合数据。这些数据应该可以跨帧保存。具体保存多少帧，可以在设计过程中间去探索。数据大BOSS可以根据实际情况，持续消去过去保存的老数据，比如说３秒或5秒以前的原始数据，５分钟之前的目标数据，等等。不同类型的数据，需要保持的时间可能不一样。

这个大BOSS对应用程序的数据写和增加记录的请求有仲裁权。应用程序不能擅自使用保存在共享内存内的数据，要先向大BOSS申请才能使用。主要是要防止正在进行读的内存，被误写。反之亦然。
已经存于数据库内部的数据，各模块可以自行查询，无须经过大BOSS允许，大BOSS向登记过的应用程序提供对应类型或类型组合的数据到达通知。同一个模块可以要求多种触发条件。这个处罚条件中间还可以包含不同类型组合的数据到达时间差。时间长可以用可称可负的相对值，也可以用绝对值。

数据源产生数据后应写入数据库，并告知大BOSS数据已经产生了，对于使用到共享内存的数据需要提前向BOSS申请（在本轮处理执行之前就要进行，异常处理应向监控报备），BOSS应给它一个可以写的内存ID，应用程序写完这个内存后，把这个ID存在数据库（参考后面的数据库内容格式），大BOSS回收这块共享内存数据写入权。
大BOSS应该有数据的读写权限控制，当赋予读权限的数据发生写操作时，应该能够报警，赋予写权限的内存写越界时，应该能够报警。大BOSS要记录每个模块的数据请求次数记录。

应用程序可以直接从数据库中提取所需数据，或者是从数据库中提取所需数据的指针，如果是指针就要申请读权限。这里的数据我们还要区分哪些是能用GPU处理的，哪些是不能用GPU处理的，内存数据在数据库内应该有这样的标签。

对于应用程序的数据，应该在数据库里记录，数据ID，数据的生产者名字和PID，数据的生产时间，数据的有效时间，数据的类型，数据格式，数据格式版本，数据内容（当数据内容较少时）或者是指向数据内容的共享内存，这个数据关联的原始数据ID，以及当前这个数据和原始数据的处理层数，这个数据关联的上一个数据的ID（也就是时间上前一个数据的ID），数据的当前使用者（那由于存在多个使用者，这个由BOSS改写，或者是这个不做记录，只有boss记录，有没有人在用，有几个人在用），这片内存是不是可以被释放，对应内存的释放规则。这个数据库的读权限是开放的，增权限可以申请，只交给生成这个数据的模块，而删、改的权限只在大BOSS。

数据的类型：：这是很详细、与具体数据物理含义相对应的类型，比如说同样是一段浮点数组，处理之前的数据可以叫原始数据，滤波处理之后的数据可以叫某某滤波器输出数据。

数据的有效时间：：不管有没有其他程序使用，超过该时间就可以放弃这个数据了，如果这个数据关联共享内存，这个内存又变成可写状态。

内存的再利用规则：：对于相同类型的内存，如果没有被读指针占用，那么优先再利用，最早数据使用的内存。把使用这片内存的数据库记录中，的内存ID改为无效，再把这片内存的ID，交给需要写内存的程序。

内存释放规则：：相同类型的内存，如果没有被读指针占用， 那么我们将释放最早的那块内存，当内存缺乏时，我们可以要求对应的读程序，终止这一片内存的使用，把内存还给数据大boss，它的对应的读程序，可以根据具体情况决定，不响应这个要求，把数据处理完。占用时间超长时，BOSS可以要求driver把这个程序从新启动。

由于我们每个具体的处理程序，我们给他配置的计算资源不一样（因为有些程序可能会出异常，以至于占着CPU不退，或则一些特殊输入条件下，占用过多的计算资源，影响整体系统连贯性，对本模块的资源占用监督由通用算法外壳实现），可能有些程序，不能消化所有的输入数据，这个程序可以向大BOSS查询（或者直接向数据库查询）还有多少剩余数据需要处理，如果剩余数据过多。这个应用程序可以选择。数据的抽取规则，比如说只处理最新的数据，或者是只处理最新两帧数据，或者是每隔一帧处理数据等等，当然这个程序也可以简化数据处理复杂度，减少搜索深度等。

数据大BOSS发现某个程序所需求的数据，已经堆积如山的时候，也就是未处理新数据已经很多了，大BOSS也可以直接通告该程序，该程序收到通告之后，可以根据实际情况采取不同的策略，或者是放弃当前处理。或者是将当前处理完，再直接要求最新数据。

应用程序在启动之时，应该告知这个大boss，它会产生什么样的数据（也就是说详细的数据类型），单个的数据块有多大，这个数据是要存在数据库里面还是存在共享内存里面，它产生数据的流量/产生频率是怎么样的。这个应用程序启动的时候，还应该告诉这个大boss，他自己的私有数据有多大，请大BOSS给他申请他私有的跨帧数据的共享内存。

同时他应该告诉这个大BOSS它需要消耗什么样的数据（相同类型数据如果要指定生产者，应用程序在自己的程序内部自行提取），或者是什么样的数据类型的组合，当这个类型数据产生的时候，由大boss通知他这个数据已经产生了。另外应用程序可以指定多种触发条件，满足其中一条，即由数据大BOSS通知应用程序进行处理。触发条件中可以包括不同数据之间等待时间。大BOSS在通知应用程序的时候，应告知应用程序，触发的条件，对应的所有数据ID。

数据大BOSS是启动的时候，需要打开特定的UDP端口，应用程序起来的时候，先向这个端口发送，我是谁，我生产的数据什么类型，我消耗的数据什么类型，我的私有持久性数据有多大，我需要什么触发条件（可以是单一条件，也可以是组合条件），我接收回复的端口，当然大BOSS也会私有的在数据库里面管理这些信息，而不是把它存在变量里面。

由于同一个程序可能会运行多个拷贝，应用程序在告诉这个大boss的时候，除了要告诉大BOSS是自己的程序什么名字，pid，还要告诉大boss是这个程序的拷贝号，拷贝号是由driver指定的。driver需要保证，死亡重启的程序具有相同的拷贝号。

数据大BOSS，可以知道，来申请数据的应用程序，是全新的程序，还是老程序，还是死过的程序的补位，根据不同的情况可以提供给应用程序不同的数据，和数据的初始化等不同的服务。

如果一个应用程序所有登记的数据输出类型，没有任何其他应用程序，需要使用那么数据BOSS，可以不向他提供数据。直到有应用程序登记需要使用这个应用程序的数据。